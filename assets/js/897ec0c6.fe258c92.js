"use strict";(self.webpackChunkgraphdb_aws_deployment_guide=self.webpackChunkgraphdb_aws_deployment_guide||[]).push([[8921],{4137:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),d=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=d(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=d(n),h=a,m=c["".concat(s,".").concat(h)]||c[h]||p[h]||o;return n?r.createElement(m,i(i({ref:t},u),{},{components:n})):r.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:a,i[1]=l;for(var d=2;d<o;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9920:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var r=n(7462),a=(n(7294),n(4137));const o={sidebar_position:2},i="Recovering the Cluster",l={unversionedId:"emergency-maintenance/EMER-002",id:"emergency-maintenance/EMER-002",title:"Recovering the Cluster",description:"The GraphDB cluster relies on quorum-based replication, meaning that the cluster should have over 50% alive nodes",source:"@site/docs/emergency-maintenance/EMER-002.md",sourceDirName:"emergency-maintenance",slug:"/emergency-maintenance/EMER-002",permalink:"/graphdb-aws-deployment-guide/docs/emergency-maintenance/EMER-002",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Handling Fault Conditions",permalink:"/graphdb-aws-deployment-guide/docs/emergency-maintenance/EMER-001"},next:{title:"Support",permalink:"/graphdb-aws-deployment-guide/docs/category/support"}},s={},d=[{value:"Recovering Individual Nodes",id:"recovering-individual-nodes",level:2},{value:"Rebuilding the cluster from a single node",id:"rebuilding-the-cluster-from-a-single-node",level:2}],u={toc:d},c="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"recovering-the-cluster"},"Recovering the Cluster"),(0,a.kt)("p",null,"The GraphDB cluster relies on quorum-based replication, meaning that the cluster should have over 50% alive nodes\nto be able to execute INSERT/DELETE operations.\nThis ensures that there will always be a majority of GraphDB nodes that always have up-to-date data."),(0,a.kt)("h2",{id:"recovering-individual-nodes"},"Recovering Individual Nodes"),(0,a.kt)("p",null,"The following procedure describes how to recover one or multiple failed nodes:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Determine if quorum is impacted.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If there is not enough nodes to form a quorum,\nconsult the ",(0,a.kt)("a",{parentName:"li",href:"#rebuilding-the-cluster-from-a-single-node"},"Rebuilding the cluster from a single node")," procedure. "))),(0,a.kt)("li",{parentName:"ol"},"If new nodes can be added with the previously used hostname or IP address\n(depending on how the nodes were added to the cluster), then:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Start the new nodes with the same address or hostname.\nAfter this, the cluster should be able to determine that the nodes are available again\nand start \u201ccatching\u201d them up with missed updates."),(0,a.kt)("li",{parentName:"ul"},"If the volume from the failed node can be mounted to the new nodes, you should do so,\nto avoid full replication from scratch, which could be time-consuming."))),(0,a.kt)("li",{parentName:"ol"},"If nodes cannot reuse the previous IP address or hostname:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"First remove the failed nodes from the cluster."),(0,a.kt)("li",{parentName:"ul"},"Add the new nodes to the cluster, it\u2019s important to add all new nodes in a single rest call.\nThis will avoid building and sending a snapshot multiple times.\nPlease note that this will trigger full replication, and it could be time-consuming depending on the size of the repository.   ")))),(0,a.kt)("h2",{id:"rebuilding-the-cluster-from-a-single-node"},"Rebuilding the cluster from a single node"),(0,a.kt)("p",null,"Sometimes, multiple nodes can fail or in other situations:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"nodes might be available,but cannot agree on the state of the cluster, "),(0,a.kt)("li",{parentName:"ul"},"cannot agree, which the leader is, and the cluster will be in a deadlocked state, unable to process write or even read requests.")),(0,a.kt)("p",null,"In such cases, the cluster can be rebuilt from a single node. "),(0,a.kt)("p",null,"Use the following procedure to rebuild the cluster from a single node:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Double check there is connectivity between the nodes."),(0,a.kt)("li",{parentName:"ol"},"Stop the GraphDB processes on all nodes. "),(0,a.kt)("li",{parentName:"ol"},"Determine the node with the highest number of processed transactions.\nThis corresponds to the log index maintained by GraphDB (Raft).\nThe steps to retrieve the log index for each node are as follows:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Get access to the nodes file system, where GraphDB stores its data."),(0,a.kt)("li",{parentName:"ul"},"Determine the size (in bytes) of ",(0,a.kt)("inlineCode",{parentName:"li"},"log.index")," file.\nThe location of this file is relative to the configured GraphDB data directory and has the following path ",(0,a.kt)("inlineCode",{parentName:"li"},"raft/transaction-log/log.index"),"."),(0,a.kt)("li",{parentName:"ul"},"Use the following formula to calculate the log index (size_in_bytes / 33) - 1."))),(0,a.kt)("li",{parentName:"ol"},"On all nodes, except for the one determined in step 2, delete the entire data directory of GraphDB."),(0,a.kt)("li",{parentName:"ol"},"On the node chosen in step 2, delete only the ",(0,a.kt)("inlineCode",{parentName:"li"},"raft/")," subfolder of the data directory."),(0,a.kt)("li",{parentName:"ol"},"Start the GraphDB processes again."),(0,a.kt)("li",{parentName:"ol"},"Create the cluster again, but ",(0,a.kt)("strong",{parentName:"li"},"make sure to issue the request to the node that was chosen in step 2"))))}p.isMDXComponent=!0}}]);